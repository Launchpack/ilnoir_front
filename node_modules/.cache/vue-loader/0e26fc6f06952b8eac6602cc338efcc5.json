{"remainingRequest":"/Users/mard/dev/ilnoir/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/mard/dev/ilnoir/src/components/Components/Common/PinchImage.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/mard/dev/ilnoir/src/components/Components/Common/PinchImage.vue","mtime":1605259984000},{"path":"/Users/mard/dev/ilnoir/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/mard/dev/ilnoir/node_modules/babel-loader/lib/index.js","mtime":315532800000},{"path":"/Users/mard/dev/ilnoir/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/mard/dev/ilnoir/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nconst DBCLICK_TIME = 200;\nexport default {\n  props: {\n    src: {\n      type: String,\n      required: true\n    },\n    alt: String,\n    minZoom: {\n      type: Number,\n      default: 1\n    },\n    maxZoom: {\n      type: Number,\n      default: 2.25\n    }\n  },\n  data() {\n    return {\n      zoom: 1,\n      minZoomBounce: .015,\n      maxZoomBounce: .015,\n      speed: .5,\n      lastX: null,\n      lastY: null,\n      x: 0,\n      y: 0,\n      zoomCenter: {\n        x: 0,\n        y: 0\n      },\n      width: 414,\n      height: window.innerHeight,\n      lastTouchTime: null,\n      clickTimer: null,\n      inMovement: false,\n      transition: {\n        transform: null,\n        origin: \"transform-origin 400ms linear\"\n      }\n    }\n  },\n  computed: {\n    zoomStyles() {\n      let transition = '';\n      if(this.transition.transform) transition += this.transition.transform;\n      if(this.transition.origin) transition += (transition.length > 0 ? ', ' : '') + this.transition.origin;\n      return {\n        transform: `scale(${this.zoom}) translate3d(${this.x}px, ${this.y}px, 0px)`,\n        transformOrigin: `${this.zoomCenter.x}px ${this.zoomCenter.y}px 0px`,\n        transition\n      }\n    }\n  },\n  methods: {\n    start(event) {\n      event.preventDefault();\n      if(event.touches.length === 2) {\n        this.handlePinchStart(event);\n      }\n      else if(event.touches.length === 1) {\n        this.handleTapStart(event);\n      }\n    },\n    end(event) {\n      event.preventDefault();\n      if(!this.inMovement && this.zoom <= this.minZoom) {\n        const timeDiff = event.timeStamp - this.lastTouchTime;\n        if(timeDiff > DBCLICK_TIME) {\n          this.resetZoom();\n        }\n      }\n      else {\n        this.lastX = 0;\n        this.lastY = 0;\n      }\n      if(event.touches.length === 0) {\n        if(this.zoom <= 1) {\n          this.lastTouchTime = event.timeStamp;\n        }\n      }\n    },\n    move(event) {\n      event.preventDefault();\n      if(event.touches.length === 2) {\n        this.handlePinchMove(event);\n      }\n      else {\n        this.handlePanMove(event);\n      }\n    },\n    resetZoom() {\n      console.log('reset');\n      //this.transition.transform = \"transform 200ms linear\";\n      this.zoom = 1;\n      this.zoomCenter.x = 0;\n      this.zoomCenter.y = 0;\n      this.x = 0;\n      this.y = 0;\n      setTimeout(() => {\n        this.transition.transform = null;\n      }, 200);\n    },\n    handlePinchStart(event) {\n      const {x,y} = this.getTouchCenter(\n        this.getTouchesCenter(event.touches[0], event.touches[1])\n      );\n      if(this.zoom < this.maxZoom) {\n        this.zoomCenter.x = x;\n        this.zoomCenter.y = y;\n      }\n      this.lastDistance = this.getZoomDistance(event.touches[0], event.touches[1]);\n    },\n    handlePinchMove(event) {\n      const zoom  = this.getZoomDistance(event.touches[0], event.touches[1]);\n      const last  = (zoom / this.lastDistance);\n      const scale = this.calcZoom(this.minZoom - this.minZoomBounce, this.maxZoom + this.maxZoomBounce, this.zoom * last);\n      if(this.zoom < this.maxZoom || (this.zoom >= this.maxZoom && scale < this.zoom)) {\n        this.zoom = scale;\n      }\n      this.lastDistance = zoom;\n    },\n    handlePanMove(event) {\n      if(this.zoom > 1) {\n        const touch = event.touches[0];\n        const x = touch.clientX;\n        const y = touch.clientY;\n        if (!this.lastX || !this.lastY) {\n          this.lastX = x;\n          this.lastY = y;\n          return null;\n        }\n        else {\n          const rect = this.$refs.image.getBoundingClientRect();\n          let diffX = (x - this.lastX) * this.speed;\n          let diffY = (y - this.lastY) * this.speed;\n          this.transition.transform = null;\n          //apply transform\n          this.x += diffX;\n          this.y += diffY;\n          //bounds\n          if(rect.left > 0 && diffX > 0) {\n            this.x -= diffX;\n          }\n          if(rect.right < this.width && diffX < 0) {\n            this.x -= diffX;\n          }\n          if(rect.top > 0 && diffY > 0) {\n            this.y -= diffY;\n          }\n          if(rect.bottom < this.height && diffY < 0) {\n            this.y -= diffY;\n          }\n          //to calc the next move\n          this.lastX = x;\n          this.lastY = y;\n        }\n      }\n    },\n    handleTapStart(event) {\n      const touch = event.touches[0];\n      const x = touch.clientX;\n      const y = touch.clientY;\n      if(!this.lastX || !this.lastY) {\n        this.lastX = x;\n        this.lastY = y;\n      }\n      if(this.lastTouchTime) {\n        const timeDiff = event.timeStamp - this.lastTouchTime;\n        if(timeDiff < DBCLICK_TIME) {\n          this.handleDoubleTap(event.touches[0]);\n          this.lastX = null;\n          this.lastY = null;\n        }\n      }\n      this.lastTouchTime = event.timeStamp;\n    },\n    handleDoubleTap(touch) {\n      let {x,y} = this.getTouchCenter({ x:touch.clientX, y: touch.clientY });\n      clearTimeout(this.clickTimeout);\n      this.inMovement = true;\n      this.transition.origin    = \"transform-origin 400ms linear\";\n      this.transition.transform = \"transform 200ms linear\";\n      if(this.zoom > this.minZoom) {\n        this.zoom = 1;\n        this.x = 0;\n        this.y = 0;\n        this.clickTimeout = setTimeout(() => {\n          this.zoomCenter.x = 0;\n          this.zoomCenter.y = 0;\n          this.inMovement = false;\n        }, 200);\n      }\n      else {\n        this.transition.origin = null;\n        this.zoomCenter.x = x;\n        this.zoomCenter.y = y;\n        this.clickTimeout = setTimeout(() => {\n          this.transition.origin = \"transform-origin 400ms linear\";\n          this.zoom              = this.maxZoom;\n          this.inMovement = false;\n        }, 200);\n      }\n    },\n    getTouchCenter({x, y}) {\n      const rect = this.$el.getBoundingClientRect();\n      return {\n        x: x - rect.left,\n        y: y - rect.top\n      }\n    },\n    calcZoom(e, t, n) {\n      return Math.min(t, Math.max(e, n))\n    },\n    getZoomDistance(e, t) {\n      return Math.sqrt(Math.pow(e.clientY - t.clientY, 2) + Math.pow(e.clientX - t.clientX, 2));\n    },\n    getTouchesCenter(touch1, touch2) {\n      return {\n        x: (touch1.clientX + touch2.clientX) / 2,\n        y: (touch1.clientY + touch2.clientY) / 2\n      }\n    },\n    bounds() {\n      const rect = this.$refs.image.getBoundingClientRect();\n      console.log(rect);\n      console.log({x:this.x,y:this.y,zoom:this.zoom});\n      if(rect.left < 0) {\n        this.x = 0;\n      }\n      else if(rect.right > this.width) {\n        this.x = 0;\n      }\n      if(rect.top < 0) {\n        this.y = 0;\n      }\n      else if(rect.bottom > this.height) {\n        this.y = 0;\n      }\n      console.log({x:this.x,y:this.y});\n    }\n  }\n}\n",{"version":3,"sources":["PinchImage.vue"],"names":[],"mappings":";;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"PinchImage.vue","sourceRoot":"src/components/Components/Common","sourcesContent":["<template>\r\n  <div class=\"pinch-wrapper\"\r\n       :style=\"zoomStyles\"\r\n       @touchstart=\"start\"\r\n       @touchmove=\"move\"\r\n       @touchend=\"end\">\r\n    <img :src=\"src\" :alt=\"alt\" class=\"pinch-img\" ref=\"image\"/>\r\n  </div>\r\n</template>\r\n\r\n<script type=\"text/babel\">\r\n  const DBCLICK_TIME = 200;\r\n  export default {\r\n    props: {\r\n      src: {\r\n        type: String,\r\n        required: true\r\n      },\r\n      alt: String,\r\n      minZoom: {\r\n        type: Number,\r\n        default: 1\r\n      },\r\n      maxZoom: {\r\n        type: Number,\r\n        default: 2.25\r\n      }\r\n    },\r\n    data() {\r\n      return {\r\n        zoom: 1,\r\n        minZoomBounce: .015,\r\n        maxZoomBounce: .015,\r\n        speed: .5,\r\n        lastX: null,\r\n        lastY: null,\r\n        x: 0,\r\n        y: 0,\r\n        zoomCenter: {\r\n          x: 0,\r\n          y: 0\r\n        },\r\n        width: 414,\r\n        height: window.innerHeight,\r\n        lastTouchTime: null,\r\n        clickTimer: null,\r\n        inMovement: false,\r\n        transition: {\r\n          transform: null,\r\n          origin: \"transform-origin 400ms linear\"\r\n        }\r\n      }\r\n    },\r\n    computed: {\r\n      zoomStyles() {\r\n        let transition = '';\r\n        if(this.transition.transform) transition += this.transition.transform;\r\n        if(this.transition.origin) transition += (transition.length > 0 ? ', ' : '') + this.transition.origin;\r\n        return {\r\n          transform: `scale(${this.zoom}) translate3d(${this.x}px, ${this.y}px, 0px)`,\r\n          transformOrigin: `${this.zoomCenter.x}px ${this.zoomCenter.y}px 0px`,\r\n          transition\r\n        }\r\n      }\r\n    },\r\n    methods: {\r\n      start(event) {\r\n        event.preventDefault();\r\n        if(event.touches.length === 2) {\r\n          this.handlePinchStart(event);\r\n        }\r\n        else if(event.touches.length === 1) {\r\n          this.handleTapStart(event);\r\n        }\r\n      },\r\n      end(event) {\r\n        event.preventDefault();\r\n        if(!this.inMovement && this.zoom <= this.minZoom) {\r\n          const timeDiff = event.timeStamp - this.lastTouchTime;\r\n          if(timeDiff > DBCLICK_TIME) {\r\n            this.resetZoom();\r\n          }\r\n        }\r\n        else {\r\n          this.lastX = 0;\r\n          this.lastY = 0;\r\n        }\r\n        if(event.touches.length === 0) {\r\n          if(this.zoom <= 1) {\r\n            this.lastTouchTime = event.timeStamp;\r\n          }\r\n        }\r\n      },\r\n      move(event) {\r\n        event.preventDefault();\r\n        if(event.touches.length === 2) {\r\n          this.handlePinchMove(event);\r\n        }\r\n        else {\r\n          this.handlePanMove(event);\r\n        }\r\n      },\r\n      resetZoom() {\r\n        console.log('reset');\r\n        //this.transition.transform = \"transform 200ms linear\";\r\n        this.zoom = 1;\r\n        this.zoomCenter.x = 0;\r\n        this.zoomCenter.y = 0;\r\n        this.x = 0;\r\n        this.y = 0;\r\n        setTimeout(() => {\r\n          this.transition.transform = null;\r\n        }, 200);\r\n      },\r\n      handlePinchStart(event) {\r\n        const {x,y} = this.getTouchCenter(\r\n          this.getTouchesCenter(event.touches[0], event.touches[1])\r\n        );\r\n        if(this.zoom < this.maxZoom) {\r\n          this.zoomCenter.x = x;\r\n          this.zoomCenter.y = y;\r\n        }\r\n        this.lastDistance = this.getZoomDistance(event.touches[0], event.touches[1]);\r\n      },\r\n      handlePinchMove(event) {\r\n        const zoom  = this.getZoomDistance(event.touches[0], event.touches[1]);\r\n        const last  = (zoom / this.lastDistance);\r\n        const scale = this.calcZoom(this.minZoom - this.minZoomBounce, this.maxZoom + this.maxZoomBounce, this.zoom * last);\r\n        if(this.zoom < this.maxZoom || (this.zoom >= this.maxZoom && scale < this.zoom)) {\r\n          this.zoom = scale;\r\n        }\r\n        this.lastDistance = zoom;\r\n      },\r\n      handlePanMove(event) {\r\n        if(this.zoom > 1) {\r\n          const touch = event.touches[0];\r\n          const x = touch.clientX;\r\n          const y = touch.clientY;\r\n          if (!this.lastX || !this.lastY) {\r\n            this.lastX = x;\r\n            this.lastY = y;\r\n            return null;\r\n          }\r\n          else {\r\n            const rect = this.$refs.image.getBoundingClientRect();\r\n            let diffX = (x - this.lastX) * this.speed;\r\n            let diffY = (y - this.lastY) * this.speed;\r\n            this.transition.transform = null;\r\n            //apply transform\r\n            this.x += diffX;\r\n            this.y += diffY;\r\n            //bounds\r\n            if(rect.left > 0 && diffX > 0) {\r\n              this.x -= diffX;\r\n            }\r\n            if(rect.right < this.width && diffX < 0) {\r\n              this.x -= diffX;\r\n            }\r\n            if(rect.top > 0 && diffY > 0) {\r\n              this.y -= diffY;\r\n            }\r\n            if(rect.bottom < this.height && diffY < 0) {\r\n              this.y -= diffY;\r\n            }\r\n            //to calc the next move\r\n            this.lastX = x;\r\n            this.lastY = y;\r\n          }\r\n        }\r\n      },\r\n      handleTapStart(event) {\r\n        const touch = event.touches[0];\r\n        const x = touch.clientX;\r\n        const y = touch.clientY;\r\n        if(!this.lastX || !this.lastY) {\r\n          this.lastX = x;\r\n          this.lastY = y;\r\n        }\r\n        if(this.lastTouchTime) {\r\n          const timeDiff = event.timeStamp - this.lastTouchTime;\r\n          if(timeDiff < DBCLICK_TIME) {\r\n            this.handleDoubleTap(event.touches[0]);\r\n            this.lastX = null;\r\n            this.lastY = null;\r\n          }\r\n        }\r\n        this.lastTouchTime = event.timeStamp;\r\n      },\r\n      handleDoubleTap(touch) {\r\n        let {x,y} = this.getTouchCenter({ x:touch.clientX, y: touch.clientY });\r\n        clearTimeout(this.clickTimeout);\r\n        this.inMovement = true;\r\n        this.transition.origin    = \"transform-origin 400ms linear\";\r\n        this.transition.transform = \"transform 200ms linear\";\r\n        if(this.zoom > this.minZoom) {\r\n          this.zoom = 1;\r\n          this.x = 0;\r\n          this.y = 0;\r\n          this.clickTimeout = setTimeout(() => {\r\n            this.zoomCenter.x = 0;\r\n            this.zoomCenter.y = 0;\r\n            this.inMovement = false;\r\n          }, 200);\r\n        }\r\n        else {\r\n          this.transition.origin = null;\r\n          this.zoomCenter.x = x;\r\n          this.zoomCenter.y = y;\r\n          this.clickTimeout = setTimeout(() => {\r\n            this.transition.origin = \"transform-origin 400ms linear\";\r\n            this.zoom              = this.maxZoom;\r\n            this.inMovement = false;\r\n          }, 200);\r\n        }\r\n      },\r\n      getTouchCenter({x, y}) {\r\n        const rect = this.$el.getBoundingClientRect();\r\n        return {\r\n          x: x - rect.left,\r\n          y: y - rect.top\r\n        }\r\n      },\r\n      calcZoom(e, t, n) {\r\n        return Math.min(t, Math.max(e, n))\r\n      },\r\n      getZoomDistance(e, t) {\r\n        return Math.sqrt(Math.pow(e.clientY - t.clientY, 2) + Math.pow(e.clientX - t.clientX, 2));\r\n      },\r\n      getTouchesCenter(touch1, touch2) {\r\n        return {\r\n          x: (touch1.clientX + touch2.clientX) / 2,\r\n          y: (touch1.clientY + touch2.clientY) / 2\r\n        }\r\n      },\r\n      bounds() {\r\n        const rect = this.$refs.image.getBoundingClientRect();\r\n        console.log(rect);\r\n        console.log({x:this.x,y:this.y,zoom:this.zoom});\r\n        if(rect.left < 0) {\r\n          this.x = 0;\r\n        }\r\n        else if(rect.right > this.width) {\r\n          this.x = 0;\r\n        }\r\n        if(rect.top < 0) {\r\n          this.y = 0;\r\n        }\r\n        else if(rect.bottom > this.height) {\r\n          this.y = 0;\r\n        }\r\n        console.log({x:this.x,y:this.y});\r\n      }\r\n    }\r\n  }\r\n</script>\r\n\r\n<style lang=\"css\" scoped>\r\n  .pinch-wrapper {\r\n    position: relative;\r\n    display: block;\r\n    height: 100%;\r\n    width: 100%;\r\n    align-items: stretch;\r\n    border-width: 0;\r\n    border-style: solid;\r\n    box-sizing: border-box;\r\n    flex-basis: auto;\r\n    flex-direction: column;\r\n    flex-shrink: 0;\r\n    margin: 0;\r\n    padding: 0;\r\n    background-color: transparent;\r\n    color: inherit;\r\n    font: inherit;\r\n    text-align: inherit;\r\n    text-decoration: none;\r\n    list-style: none;\r\n    min-height: 0;\r\n    min-width: 0;\r\n  }\r\n  .pinch-wrapper:hover {\r\n    will-change: transform;\r\n  }\r\n  .pinch-img {\r\n    position: absolute;\r\n    width: auto !important;\r\n    height: auto !important;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n    top: 0;\r\n    max-width: 100%;\r\n    max-height: 100%;\r\n    object-position: center;\r\n    margin: auto;\r\n  }\r\n</style>"]}]}